/**
 * Generated by orval v6.10.3 🍺
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useQuery, useMutation } from "react-query";
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from "react-query";
import type {
  AuthenticateUser200,
  LoginRequestDto,
  RefreshAndGetAuthenticationToken200,
  LogoutUser200,
} from "../model";
import { axiosInstance } from "../../http/axiosInstance";

export const authenticateUser = (loginRequestDto: LoginRequestDto) => {
  return axiosInstance<AuthenticateUser200>({
    url: `/api/auth/login`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: loginRequestDto,
  });
};

export type AuthenticateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authenticateUser>>
>;
export type AuthenticateUserMutationBody = LoginRequestDto;
export type AuthenticateUserMutationError = unknown;

export const useAuthenticateUser = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authenticateUser>>,
    TError,
    { data: LoginRequestDto },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authenticateUser>>,
    { data: LoginRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return authenticateUser(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof authenticateUser>>,
    TError,
    { data: LoginRequestDto },
    TContext
  >(mutationFn, mutationOptions);
};
export const refreshAndGetAuthenticationToken = (signal?: AbortSignal) => {
  return axiosInstance<RefreshAndGetAuthenticationToken200>({
    url: `/api/auth/refreshtoken`,
    method: "get",
    signal,
  });
};

export const getRefreshAndGetAuthenticationTokenQueryKey = () => [
  `/api/auth/refreshtoken`,
];

export type RefreshAndGetAuthenticationTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof refreshAndGetAuthenticationToken>>
>;
export type RefreshAndGetAuthenticationTokenQueryError = unknown;

export const useRefreshAndGetAuthenticationToken = <
  TData = Awaited<ReturnType<typeof refreshAndGetAuthenticationToken>>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof refreshAndGetAuthenticationToken>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRefreshAndGetAuthenticationTokenQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof refreshAndGetAuthenticationToken>>
  > = ({ signal }) => refreshAndGetAuthenticationToken(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof refreshAndGetAuthenticationToken>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const logoutUser = (signal?: AbortSignal) => {
  return axiosInstance<LogoutUser200>({
    url: `/api/auth/logout`,
    method: "get",
    signal,
  });
};

export const getLogoutUserQueryKey = () => [`/api/auth/logout`];

export type LogoutUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof logoutUser>>
>;
export type LogoutUserQueryError = unknown;

export const useLogoutUser = <
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof logoutUser>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogoutUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logoutUser>>> = ({
    signal,
  }) => logoutUser(signal);

  const query = useQuery<Awaited<ReturnType<typeof logoutUser>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};
